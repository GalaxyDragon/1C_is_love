Для хранения пар номер-фамилия подойдёт структура подобная unordered_map из C++ - это позволит за O(1) доставать
пару для конкретного значения, требует O(n) доп. памяти
 Для того, чтобы находить промежуток заведём дерево, из каждой вершины которого выходят
10 листьев '0-9', и оно хранит все проходящие через него номера.
 (по сути - бор с доп. информцией в вершине)
 Асимптотика доставания фамилий по началу номера - О(длина использующихся номеров).
 Асимптотика хранения бора по памяти: O(n) доп памяти, где n чило номеров при большом числе номеров,
  O(n*m) - инче, где m - длина номера

 Для функции поиска по паттерну:
 Простой вариант: хранить все ноды, подходящие под условие, и итеративно переходить по цифре, если она извества,
 и добавлять всех детей данной ноды иначе.
 Ассимптотика - по числу подходящих номеров, т.е. эеспоненциальная в худшем случае

 Сложный вариант:
 использовать алгоритм ахо-карасика, в качестве текста используя номера раздёлённые неким служебным символом
 пример, как исползовать ахо-корасика для поиска по строке шаблона:
 1254#1234#1134#1435 - набор 4-значных номеров, где мы ищем паттерн 12*4
 ахо-корасик покажет, на каких позициях встречаются паттерны 12 и 4, от места их вхождения надо отступить 0 для вхожений
 12 и 3 для вхождений 4, и в данных позициях увеличить счётчик на 1. Те номера, в началах которых счётчик равен числу
 подпаттернов (12 и 4 в данном случае, то есть 2), вывести.
 Ассимптотика - суммарная длинна номеров+число вхождений
 подпаттернов по отдельности (тем хуже, чем больше различных подпаттернов. можно использовать глупый алгоритм для
 большого числа подпаттернов, и сложный для малого.)

 Релизация готового ахо-корасика собственного изгодавления в отдельном cpp, осталось только присоединить нормально
 (не сделано)

 If you read it then you are breathtaking! c:
